/// Verifies the SHA-256 manifest of bundled Python files at agent launch.
///
/// The integrity manifest (`integrity.json`) is generated during the build
/// pipeline and embedded in the app bundle alongside the Python layer.
/// Verifying it at startup prevents tampered Python code from running under
/// the agent's entitlements.
///
/// Also supports periodic re-verification on a configurable timer to detect
/// post-launch file tampering.

import CryptoKit
import Foundation
import os.log

// MARK: - IntegrityResult

/// The outcome of a manifest verification pass.
public enum IntegrityResult: Sendable, Equatable {
    /// All files matched their expected SHA-256 digests.
    case passed

    /// One or more files failed the digest check.
    ///
    /// - Parameter violations: Relative file paths whose digests did not match.
    case failed(violations: [String])

    /// `integrity.json` was not found in the resources directory.
    case manifestMissing
}

// MARK: - ManifestPayload (private JSON shape)

private struct ManifestPayload: Decodable {
    /// Map of relative file path → lowercase hex SHA-256 digest.
    let files: [String: String]
}

/// Shape of the `integrity.sig` file generated by the build script.
private struct ManifestSignature: Decodable {
    /// HMAC-SHA256 of the manifest JSON content, hex-encoded.
    let hmac_sha256: String
    /// The HMAC key, hex-encoded. Embedded in the signed bundle.
    let key_hex: String
    /// SHA-256 of the manifest JSON content, hex-encoded (quick check).
    let manifest_sha256: String
}

// MARK: - IntegrityChecker

/// Verifies Python layer file integrity via SHA-256 manifest.
///
/// Use the static `verify(bundleResourcesPath:)` for one-shot checks,
/// or create an instance for periodic background verification.
///
/// The instance methods use Swift actor isolation for thread-safe periodic
/// check management (replaces the previous `@unchecked Sendable` + NSLock).
public actor IntegrityChecker {

    private static let log = os.Logger(
        subsystem: "com.kmflow.agent",
        category: "IntegrityChecker"
    )

    // MARK: - Periodic Checking

    /// Callback invoked when a periodic check detects a violation.
    public typealias ViolationHandler = @Sendable (IntegrityResult) -> Void

    private let bundleResourcesPath: URL
    private let checkInterval: TimeInterval
    private let violationHandler: ViolationHandler?
    private var periodicTask: Task<Void, Never>?

    /// Create a checker for periodic integrity verification.
    ///
    /// - Parameters:
    ///   - bundleResourcesPath: Root of the Python resources directory.
    ///   - checkInterval: Seconds between periodic checks (default: 300 = 5 min).
    ///   - violationHandler: Called when a periodic check fails.
    public init(
        bundleResourcesPath: URL,
        checkInterval: TimeInterval = 300,
        violationHandler: ViolationHandler? = nil
    ) {
        self.bundleResourcesPath = bundleResourcesPath
        self.checkInterval = checkInterval
        self.violationHandler = violationHandler
    }

    deinit {
        periodicTask?.cancel()
    }

    /// Start periodic integrity checking in the background.
    ///
    /// Returns immediately. Checks run every `checkInterval` seconds.
    /// Call `stopPeriodicChecks()` to cancel.
    public func startPeriodicChecks() {
        guard periodicTask == nil else { return }

        let path = bundleResourcesPath
        let interval = checkInterval
        let handler = violationHandler

        periodicTask = Task.detached {
            while !Task.isCancelled {
                try? await Task.sleep(nanoseconds: UInt64(interval * 1_000_000_000))
                guard !Task.isCancelled else { break }

                let result = IntegrityChecker.verify(bundleResourcesPath: path)
                switch result {
                case .passed:
                    break
                case .failed, .manifestMissing:
                    IntegrityChecker.log.error("Periodic integrity check FAILED")
                    handler?(result)
                }
            }
        }
    }

    /// Stop periodic integrity checks.
    public func stopPeriodicChecks() {
        periodicTask?.cancel()
        periodicTask = nil
    }

    // MARK: - Public Static API

    /// Verify every file listed in `integrity.json` against its expected digest.
    ///
    /// - Parameter bundleResourcesPath: The directory that contains both
    ///   `integrity.json` and the Python source tree (typically
    ///   `Bundle.main.resourceURL`).
    /// - Returns: `.passed`, `.failed(violations:)`, or `.manifestMissing`.
    public static func verify(bundleResourcesPath: URL) -> IntegrityResult {
        let manifestURL = bundleResourcesPath.appendingPathComponent("integrity.json")

        // Read manifest.
        guard let manifestData = try? Data(contentsOf: manifestURL) else {
            log.error("integrity.json not found at \(manifestURL.path, privacy: .public)")
            return .manifestMissing
        }

        // Verify HMAC signature if integrity.sig exists.
        //
        // Threat model: the HMAC key is co-located with the signature inside
        // the code-signed bundle. This protects against accidental corruption
        // and naive file replacement, NOT against a sophisticated attacker who
        // can regenerate both files. Full tamper protection relies on macOS
        // code signing (Hardened Runtime + notarization). The HMAC is a
        // defense-in-depth layer for environments where codesign verification
        // may not run (e.g. development builds, CI).
        let sigURL = bundleResourcesPath.appendingPathComponent("integrity.sig")
        if let sigData = try? Data(contentsOf: sigURL) {
            if !verifyManifestSignature(manifestData: manifestData, signatureData: sigData) {
                log.error("Integrity manifest HMAC verification FAILED — possible tampering")
                return .failed(violations: ["integrity.json (HMAC mismatch)"])
            }
            log.info("Integrity manifest HMAC verified")
        } else {
            #if DEBUG
            log.warning("integrity.sig not found — HMAC verification skipped (debug build)")
            #else
            log.error("integrity.sig not found — required in release builds")
            return .failed(violations: ["integrity.sig (missing)"])
            #endif
        }

        // Decode manifest.
        let manifest: ManifestPayload
        do {
            manifest = try JSONDecoder().decode(ManifestPayload.self, from: manifestData)
        } catch {
            log.error("Failed to decode integrity.json: \(error.localizedDescription, privacy: .public)")
            return .manifestMissing
        }

        var violations: [String] = []

        for (relativePath, expectedHex) in manifest.files.sorted(by: { $0.key < $1.key }) {
            let fileURL = bundleResourcesPath.appendingPathComponent(relativePath)

            guard let fileData = try? Data(contentsOf: fileURL) else {
                log.error("Integrity violation — file missing: \(relativePath, privacy: .public)")
                violations.append(relativePath)
                continue
            }

            let actualHex = sha256Hex(data: fileData)
            if actualHex != expectedHex.lowercased() {
                log.error(
                    "Integrity violation — digest mismatch: \(relativePath, privacy: .public) expected=\(expectedHex, privacy: .public) actual=\(actualHex, privacy: .public)"
                )
                violations.append(relativePath)
            }
        }

        if violations.isEmpty {
            log.info("Integrity check passed (\(manifest.files.count, privacy: .public) files verified)")
            return .passed
        } else {
            log.error("Integrity check FAILED — \(violations.count, privacy: .public) violation(s)")
            return .failed(violations: violations)
        }
    }

    // MARK: - Private

    /// Compute the lowercase hex-encoded SHA-256 digest of `data`.
    static func sha256Hex(data: Data) -> String {
        let digest = SHA256.hash(data: data)
        return digest.map { String(format: "%02x", $0) }.joined()
    }

    /// Verify the HMAC-SHA256 signature of the integrity manifest.
    ///
    /// The signature file contains the HMAC key (embedded in the code-signed
    /// bundle) and the expected HMAC. Returns `true` if verification passes.
    private static func verifyManifestSignature(manifestData: Data, signatureData: Data) -> Bool {
        guard let sig = try? JSONDecoder().decode(ManifestSignature.self, from: signatureData) else {
            log.error("Failed to decode integrity.sig")
            return false
        }

        // Quick check: verify SHA-256 of manifest content.
        let actualSHA = sha256Hex(data: manifestData)
        guard actualSHA == sig.manifest_sha256 else {
            log.error("Manifest SHA-256 mismatch")
            return false
        }

        // HMAC-SHA256 verification using CryptoKit (constant-time comparison).
        guard let keyData = Data(hexString: sig.key_hex) else {
            log.error("Invalid HMAC key hex in integrity.sig")
            return false
        }
        guard let claimedHMACData = Data(hexString: sig.hmac_sha256) else {
            log.error("Invalid HMAC hex in integrity.sig")
            return false
        }

        let key = SymmetricKey(data: keyData)
        return HMAC<SHA256>.isValidAuthenticationCode(
            claimedHMACData,
            authenticating: manifestData,
            using: key
        )
    }
}

// MARK: - Data hex string helper

private extension Data {
    /// Initialize from a hex-encoded string.
    init?(hexString: String) {
        let chars = Array(hexString)
        guard chars.count.isMultiple(of: 2) else { return nil }
        var bytes: [UInt8] = []
        bytes.reserveCapacity(chars.count / 2)
        for i in stride(from: 0, to: chars.count, by: 2) {
            guard let byte = UInt8(String(chars[i...i+1]), radix: 16) else { return nil }
            bytes.append(byte)
        }
        self.init(bytes)
    }
}
